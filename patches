#!/usr/bin/python
#
# patches - QEMU Patch Tracking System
#
# Copyright IBM, Corp. 2013
#
# Authors:
#  Anthony Liguori <aliguori@us.ibm.com>
#
# This work is licensed under the terms of the GNU GPLv2 or later.
# See the COPYING file in the top-level directory.
#

from argparse import ArgumentParser
from patchlib import config, data, query

def do_scan(args):
    from patchlib import scan
    return scan.main(args)

def do_notify(args):
    from patchlib import notify
    return notify.main(args)

def do_list(args):
    with open(config.get_json_path(), 'rb') as fp:
        patches = data.parse_json(fp.read())

    if args.format == 'notmuch':
        query.dump_notmuch_query(patches, args)
    elif args.format == 'oneline':
        query.dump_oneline_query(patches, args)
    elif args.format == 'full':
        query.dump_full_query(patches, args)
    else:
        raise Exception('unknown output type %s' % args.output)

    return 0

def do_fetch(args):
    from patchlib import fetch
    return fetch.main(args)

def do_apply(args):
    from patchlib import apply
    return apply.main(args)

def do_init(args):
    from patchlib import init
    return init.main(args)

def strlist(value):
    if value.find(';') == -1:
        return [value]
    return value.split(';')

def main(args):
    import os.path

    parser = ArgumentParser()
    parser.add_argument('--config', type=str,
                        help='Path to configuration file')

    subparsers = parser.add_subparsers(title='Subcommands',
                                       description='Valid subcommands',
                                       help='Subcommand help')

    subparser = subparsers.add_parser('init',
                                      help='Create a new patches configuration in the current directory')
    subparser.add_argument('url', type=str, nargs='*', help='URL of remote JSON file')
    subparser.set_defaults(func=do_init)

    subparser = subparsers.add_parser('scan',
                                      help='Scan mailing list for patches')
    subparser.set_defaults(func=do_scan)

    subparser = subparsers.add_parser('notify',
                                      help='Notify mailing list of patch status')
    subparser.add_argument('--smtp-server', type=str, help='SMTP server to send mail from')
    subparser.add_argument('--sender', type=str, help='Default sender of notifications')
    subparser.add_argument('--events', type=strlist, help='List of notification events')
    subparser.add_argument('--dry-run', action='store_true', help='Do not take any real actions')
    subparser.add_argument('--fake', action='store_true', help='Update the notification database but do not send mail')
    subparser.set_defaults(func=do_notify)

    subparser = subparsers.add_parser('list',
                                      help='List pending patches')
    subparser.add_argument('query', type=str, nargs='*', default=['status:unapplied'], help='Search query')
    subparser.add_argument('--format', type=str, default='full', help='Select output format (default "oneline")')
    subparser.set_defaults(func=do_list)

    subparser = subparsers.add_parser('fetch',
                                      help='Fetch patch info from remote server')
    subparser.add_argument('url', type=str, nargs='?', help='URL of remote JSON file')
    subparser.set_defaults(func=do_fetch)

    subparser = subparsers.add_parser('apply',
                                      help='Apply a patch or pull request')
    subparser.add_argument('mid', type=str, help='Message ID of the leader')
    subparser.set_defaults(func=do_apply)

    args = parser.parse_args(args)
    config.setup(args.config)
    return args.func(args)

if __name__ == '__main__':
    import sys
    sys.exit(main(sys.argv[1:]))
